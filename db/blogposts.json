[
	{
		"id": 0,
		"name": "hello-world",
		"header": "Hello, world!",
		"subheader": "Welcome to my devblog.",
		"date": "01/12/2018 17:30",
		"content": "<p>Hello! I am Tom and this is my blog - in short, I study Computer Science, I do lots of programming and I'm an avid gamer. I will be posting all kinds of articles - be it my reflections on the games industry, programming concepts/ideas, perhaps even tutorials.</p><p>This really just serves as an introduction - I appreciate you visiting my website and I hope you check back from time to time!</p>"
	},
	{
		"id": 1,
		"name": "tool-recs-genie",
		"header": "Tool recommendations: GENie",
		"subheader": "Making build systems easy since… 2014, apparently.",
		"date": "05/02/2019 15:45",
		"content": "<p>A word of warning before you indulge yourself in this hugely interesting article: My advice here is based on my own experiences of using C++ for software development. Your mileage may vary based on the language chosen, your dependencies and obviously the kind of software you’re working on. </p><h3>What even is a build system?</h3><p>You wouldn’t normally consider building your source code to be an important thing in learning software development – or at least I didn’t, until I’ve come out of the beginner stage and started working on more complex coding projects. You quickly come to the realisation that it’s one of the most vital parts of the process, and also one of the most challenging ones. </p><p>Sure, you can get away just fine with providing a Visual Studio solution if you only target your software’s source code to be built on Windows machines. Equally, when I developed something for GNU/Linux, I only provided a Makefile – my distro was usually Debian or Ubuntu with barely any changes, so it was quite easy to write it and test if it’d work for others. </p><p>But now let’s assume you want to write an open-source app that would easily compile on any system using any toolchain. You start writing a Makefile for GNU, then fire up Visual Studio on Windows and create a new solution. Then you realise you need to link third-party libraries.  Oh yes, did I mention some libraries come in different versions for debug and release builds?</p><h3>Common solutions</h3><p>From what I’ve seen, <a href=\"https://cmake.org/\" target=\"_blank\">CMake</a> seems to be by far the most popular option for creating cross-platform build systems when it comes to C/C++ projects. Sure enough, the concept sounds very promising, and I’ve seen a number of open-source programs use it successfully. Myself, however, I couldn’t get used to it. CMake operates on scripts – each stored in a CMakeLists.txt file – that generates the build files. It’s got its own syntax and a set of commands that make it a programming language of its own, in a way. </p><p>This is my problem; it’s too steep of a learning curve for me, and that becomes very frustrating when you want to just start writing program code, build and test it. I am sure it is very powerful once you’ve mastered it, but for my projects, CMake just doesn’t cut it simply because of this aspect.</p><h3>The most random find on GitHub</h3><p>I must say I consider myself lucky to have discovered this neat little tool. The story goes like this:</p><p>One day during 2018 (oddly specific), I wanted to do some more graphics programming – at that point, my 3D engine (<a href=\"https://github.com/tomezpl/LepusEngine\" target=\"_blank\">LepusEngine</a>) used a VS2017 solution for Windows building and a Makefile for creating GNU/Linux builds with g++.  At that point I’d forgotten what my code looked like due to being busy with other things throughout my academic year, so I decided to build it, run it and see what it actually does, then dive into the code. Turns out <span style=\"font-style: italic\">2018 me</span> decided to run the Linux build first.</p><p>As I later found out, the Makefile was significantly out-of-date and was actually missing key components of the engine – I used to manually add source files into the Makefile, which in itself is not actually a bad thing (perhaps safer than including all *.cpp files). Obviously my terminal was flooded with errors from the compiler in larger amounts than insults I get from random angry teenagers on online gaming voice comms, and that’s quite an accomplishment.</p><p>Either way, at the same time I also began to look at other people’s graphics code and eventually spotted <a href=\"https://github.com/bkaradzic\">bkaradzic</a>’s <a href=\"https://github.com/bkaradzic/bgfx\">bgfx</a> library. I was ready to clone and have a play with it, but something else actually struck my attention – the building section in the README. It explained how it uses <a href=\"https://github.com/bkaradzic/genie\">GENie</a> – another project of that developer – to prepare it for building. I immediately switched to the GENie repo, downloaded the kindly provided Windows binary, and had a play.</p><p>I’ve used it for nearly a year now. Verdict? In short: it’s amazingly well done. The project description does mention it has roots in Premake (which I personally haven’t tried) so perhaps it’s not the first system like this, but to me it doesn’t matter – it’s the ideal build generator for me, and I will keep using it for my own projects. However, let’s look at all of this rationally and consider its pros and cons:</p><table style=\"text-align: center; display: block; margin: 0 auto; width: 80em\"><tr><td style=\"width: 40em; background-color: #008000; color: black; font-weight: bold; text-align: center; font-size: 2em\">Strengths</td><td style=\"width: 40em; background-color: red; color: black; font-weight: bold; text-align: center; font-size: 2em\">Weaknesses</td></tr><tr><td style=\"width: 40em; background-color: #005000; color: black\"><p>Uses Lua. If you’re familiar with the syntax, you’re pretty much set.</p><p>Able to generate various commonly used project types including, but not limited to: vs, make, xcode</p><p>Considering it’s a fork of Premake itself, and that it’s open source, chances are new project types can be added fairly quickly and easily</p><p>Building from source doesn’t (or at least in my experience didn’t) require any dependencies. Alternatively, up-to-date binaries are provided.</p><p>Commands allow for highly customisable builds</p><p>Well documented scripting reference</p><p>Not overly complex – my 3D engine build script fits in under 200 lines, and could be a lot shorter if I removed some duplicates.</p></td><td style=\"width: 40em; background-color: #800000; color: black\"><p>Certain build systems might not produce perfect project configs. VS2017 by default, for example, doesn’t enable debug information generation in the debug config, and will use Win8.1 SDK even if it’s not installed. Can be solved quite easily.</p><p>For cross-platform build systems, you still have to declare a fair amount of platform-specific commands to be passed on compile time. Luckily platform detection methods are provided for the script.</p></td></tr></table><p>As you can see, while it’s not perfect, the advantages of using GENie are certainly overwhelming. I wrote this post in part to share a bit about what my development environment is like, as well as to help attract some attention to this project (since I think it deserves it) and make life easier for some devs, be it beginners or veterans.</p><p style=\"font-weight: bold; font-style: italic\">Happy coding!</p>"
	}
]